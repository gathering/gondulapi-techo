/*
Tech:Online backend
Copyright 2020, Kristian Lyngst√∏l <kly@kly.no>

This program is free software; you can redistribute it and/or
modify it under the terms of the GNU General Public License
as published by the Free Software Foundation; either version 2
of the License, or (at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program; if not, write to the Free Software
Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
*/

package techo

import (
	"fmt"
	"strings"
	"time"

	"github.com/gathering/gondulapi"
	"github.com/gathering/gondulapi/db"
	"github.com/gathering/gondulapi/receiver"
	log "github.com/sirupsen/logrus"
)

// Track is a category of tasks with a separate set of stations.
// TODO update desc.
type Track struct {
	ID          string `column:"id" json="id"` // Unique
	Name        string `column:"name" json="name"`
	Description string `column:"description" json="description"`
}

// Task is a single task, with sequence number for sorting, shortname is
// used by the verify-script and matches the Test object's "task" field
// (not ideal, but it works). TODO update desc.
type Task struct {
	TrackID     *string `column:"track_id" json="track_id"`
	LocalID     *string `column:"local_id" json="local_id"` // Unique within a track
	Sequence    *int    `column:"sequence" json="sequence"` // For sorting
	Name        *string `column:"name" json="name"`
	Description *string `column:"description" json="description"`
	// TODO remove?
	//Tests []Test `column:"-" json="-"`
}

// Tasks contains a list of tasks.
type Tasks []*Task

// StatusUser is used to display everything a user/participant really needs
// to know right now.
// TODO remove?
// type StatusUser struct {
// 	UserID    string    `column:"user_id" json="user_id"`
// 	Message   *string   `column:"message" json="message"`
// 	TimeSlot  *TimeSlot `column:"time_slot" json="time_slot"`
// 	StationID *Station  `column:"station_id" json="station_id"`
// 	Tasks     Tasks     `column:"tasks" json="tasks"`
// }

// Old Test from tech-online repo.
// Test is a single test-case, sent from the verify-script
// type Test struct {
// 	Title       string
// 	Description string
// 	Status      string
// 	Task        string
// }

// Test is a single test(result), with all relevant descriptions. It is
// used mainly for writes, but can be Get() from as well - because why not.
// TODO update desc.
type Test struct {
	TrackID     *string    `column:"track_id" json="track_id"`
	TaskID      *string    `column:"task_id" json="task_id"`
	StationID   *int       `column:"station_id" json="station_id"`
	Title       *string    `column:"title" json="title"`             // Short title
	Description *string    `column:"description" json="description"` // Longer description for the test
	Status      *string    `column:"status" json="status"`           // Actual status-result. Should probably be OK/WARN/FAIL (TODO)
	UpdateTime  *time.Time `column:"update_time" json="update_time"` // Time updates. Set by DB if left empty.
	// TODO remove?
	//Participant *string    `column:"" json=""`            // Participant ID... somewhat legacy. Might be removed.
	// CompoundID []interface{} `column:"-" json="-"` // see mkid
}

// Tests is an array of tests associated with a single station (and
// track). It is used for reading all status entries for a single station.
// In the future, it might support Delete() to clear all status for a
// station.
// TODO update desc.
type Tests []Test

// StatusStation allows GETting status per station. Unlike StatusUser, it
// is not divided into tasks. I'm not sure why not, except lazyness.
// type StatusStation struct {
// 	Tests []*Test
// }

func init() {
	// receiver.AddHandler("/status/station/", func() interface{} { return &StatusStation{} })
	// receiver.AddHandler("/status/user/", func() interface{} { return &StatusUser{} })
	receiver.AddHandler("/task/", func() interface{} { return &Task{} })
	receiver.AddHandler("/tasks/", func() interface{} { return &Tasks{} })
	receiver.AddHandler("/test/", func() interface{} { return &Test{} })
	// receiver.AddHandler("/tests/track/", func() interface{} { return &StationTests{} })
}

// Get gets a status user.
func (su *StatusUser) Get(request *gondulapi.Request) error {
	if element == "" {
		return gondulapi.Errorf(400, "GET requires an element")
	}
	su.UserID = element
	// TODO outdated
	msg := "Tech:Online is over, and the jury is out! Tune in on discord at 21:00 for a speed walkthrough and when we announce the lucky winners of a ticket for The Gathering 2021."
	su.Message = &msg
	station := &StationUser{}
	station.Get(element)
	if station.ID != 0 {
		su.Station = station
	}
	ts := &TimeSlot{}
	e := ts.Get(element)
	if e == nil {
		su.TimeSlot = ts
	}

	rows, err := db.DB.Query("SELECT title,description,status,task FROM status WHERE participantid = $1", element)
	if err != nil {
		return err
	}
	defer func() {
		rows.Close()
	}()
	su.Tasks.Get("")
	tasks := make(map[string]*Task)
	for _, t := range su.Tasks {
		tasks[*t.Shortname] = t
	}
	for {
		ok := rows.Next()
		if !ok {
			break
		}
		t := &Test{}
		err = rows.Scan(&t.Title, &t.Description, &t.Status, &t.Task)
		if err != nil {
			return err
		}
		if tasks[t.Task] == nil {
			nt := &Task{}
			nt.ShortName = &t.Task
			seq := 99
			nt.Sequence = &seq
			nt.Name = &t.Task
			nt.Tests = make([]Test, 0)
			tasks[t.Task] = nt
			su.Tasks = append(su.Tasks, nt)
		}
		tasks[t.Task].Tests = append(tasks[t.Task].Tests, *t)
	}
	return nil
}

// Put puts a status station.
func (ss StatusStation) Put(request *gondulapi.Request) (gondulapi.WriteReport, error) {
	if element == "" {
		return gondulapi.WriteReport{Failed: 1}, gondulapi.Errorf(400, "PUT requires an element path to put")
	}
	station := Station{}
	err := station.Get(element)
	if err != nil {
		return gondulapi.WriteReport{Failed: 1}, gondulapi.Errorf(404, "No such station")
	}
	ss.Delete(element)
	for _, t := range ss.Tests {
		_, err := db.DB.Exec("INSERT INTO status (stationid,title,description,status,task,participantid) VALUES($1,$2,$3,$4,$5,$6)", element, t.Title, t.Description, t.Status, t.Task, station.User)
		if err != nil {
			log.Printf("lol: %v", err)
		}
	}
	return gondulapi.WriteReport{}, nil
}

// Get gets a status station.
func (ss *StatusStation) Get(request *gondulapi.Request) error {
	if element == "" {
		return gondulapi.Errorf(400, "GET requires an element")
	}

	rows, err := db.DB.Query("SELECT title,description,status,task FROM status WHERE stationid = $1 order by title", element)
	if err != nil {
		return err
	}
	defer func() {
		rows.Close()
	}()
	ss.Tests = make([]*Test, 0)
	for {
		ok := rows.Next()
		if !ok {
			break
		}
		t := &Test{}
		err = rows.Scan(&t.Title, &t.Description, &t.Status, &t.Task)
		if err != nil {
			return err
		}
		ss.Tests = append(ss.Tests, t)
	}
	return nil
}

// Delete deletes a status user.
func (ss StatusStation) Delete(request *gondulapi.Request) (gondulapi.WriteReport, error) {
	if element == "" {
		return gondulapi.WriteReport{Failed: 1}, gondulapi.Errorf(400, "DELETE requires an element")
	}
	_, err := db.DB.Exec("DELETE FROM status WHERE stationid = $1", element)
	if err != nil {
		log.Printf("%v", err)
	}
	return gondulapi.WriteReport{}, err
}

// Get gets tasks.
func (tasks *Tasks) Get(request *gondulapi.Request) error {
	rows, err := db.DB.Query("SELECT seq,shortname,name,description FROM tasks ORDER BY seq")
	if err != nil {
		return err
	}
	defer func() {
		rows.Close()
	}()
	for {
		ok := rows.Next()
		if !ok {
			break
		}
		task := &Task{}
		err = rows.Scan(&task.Sequence, &task.Shortname, &task.Name, &task.Description)
		if err != nil {
			return err
		}
		task.Tests = make([]Test, 0)
		*tasks = append(*tasks, task)
	}
	if err != nil {
		return err
	}
	return nil
}

// Get gets a task.
func (task *Task) Get(request *gondulapi.Request) error {
	if element == "" {
		return gondulapi.Errorf(400, "GET requires an element")
	}
	rows, err := db.DB.Query("SELECT seq,shortname,name,description FROM tasks WHERE shortname = $1", element)
	if err != nil {
		return err
	}
	defer func() {
		rows.Close()
	}()
	ok := rows.Next()
	if !ok {
		return gondulapi.Errorf(404, "Task not found")
	}
	err = rows.Scan(&task.Sequence, &task.Shortname, &task.Name, &task.Description)
	if err != nil {
		return err
	}
	return nil
}

// Delete deletes a task.
func (task Task) Delete(request *gondulapi.Request) (gondulapi.WriteReport, error) {
	if element == "" {
		return gondulapi.WriteReport{Failed: 1}, gondulapi.Errorf(400, "PUT requires an element path to put")
	}
	_, err := db.DB.Exec("DELETE FROM tasks WHERE shortname = $1", element)
	log.Printf("delete task err: %v", err)
	return gondulapi.WriteReport{Ok: 1}, nil
}

// Put puts a task.
func (task Task) Put(request *gondulapi.Request) (gondulapi.WriteReport, error) {
	if task.Shortname == nil || *task.Shortname == "" {
		task.Shortname = &element
	}
	if element == "" {
		return gondulapi.WriteReport{Failed: 1}, gondulapi.Errorf(400, "PUT requires an element path to put")
	}
	if element != *task.Shortname {
		return gondulapi.WriteReport{Failed: 1}, gondulapi.Errorf(400, "PUT where path element (%s) doesn't match shortname (%s) - pick one", element, task.Shortname)
	}

	if task.exists(element) {
		return db.Update("tasks", "shortname", task.Shortname, task)
	}

	return db.Insert("tasks", task)
}

func (task *Task) exists(request *gondulapi.Request) bool {
	var existing Task
	err := existing.Get(element)
	exists := true
	if err != nil {
		gerr, ok := err.(gondulapi.Error)
		if ok && gerr.Code == 404 {
			exists = false
		}
	}
	return exists
}

// Get an array of tests associated with a station, uses the
// url path /test/track/$TRACKID/station/$STATIONID for readability.
func (st *StationTests) Get(request *gondulapi.Request) error {
	track, station := "", 0
	element = strings.Replace(element, "/", " ", -1)
	_, err := fmt.Sscanf(element, "%s station %d", &track, &station)
	if err != nil {
		return gondulapi.Errorf(400, "Invalid search string, need track/%%s/station/%%d, got station/%s, err: %v", element, err)
	}
	return db.SelectMany(st, "results", "track", "=", track, "station", "=", station)
}

// mkid is a convenience-function to parse the URL for a test and backfill
// it into t, building t.id while we're at it which can be parsed to any
// gondulapi.db function that accepts variadic search arguments.
func (t *Test) mkid(request *gondulapi.Request) error {
	t.Track = new(string)
	t.StationID = new(int)
	t.Hash = new(string)
	element = strings.Replace(element, "/", " ", -1)
	_, err := fmt.Sscanf(element, "track %s station %d hash %s", t.Track, *t.StationID, t.Hash)
	if err != nil {
		return gondulapi.Errorf(400, "Invalid search string, need track/%%s/station/%%d/hash/%%s, got %s, err: %v", element, err)
	}
	t.CompoundID = []interface{}{"track", "=", t.Track, "station", "=", t.StationID, "hash", "=", t.Hash}
	return nil
}

// Get a single test
func (t *Test) Get(request *gondulapi.Request) error {
	if err := t.mkid(element); err != nil {
		return err
	}
	return db.Get(t, "results", t.CompoundID...)
}

// Put a single test - uses upsert: if it exists, it is updated, if it
// doesn't it is added.
func (t Test) Put(request *gondulapi.Request) (gondulapi.WriteReport, error) {
	if err := t.mkid(element); err != nil {
		return gondulapi.WriteReport{Failed: 1}, err
	}
	return db.Upsert(t, "results", t.CompoundID...)
}

// Post a single test - Also uses upsert, but ignores the URL and requires
// all fields to be present in the data instead.
func (t Test) Post(request *gondulapi.Request) (gondulapi.WriteReport, error) {
	if t.Track == nil || *t.Track == "" || t.StationID == nil || *t.StationID == 0 || t.Hash == nil || *t.Hash == "" {
		return gondulapi.WriteReport{Failed: 1}, gondulapi.Errorf(400, "POST must define both track and station as non-0 values")
	}
	return db.Upsert(t, "results", "track", "=", t.Track, "station", "=", t.StationID, "hash", "=", t.Hash)
}

// Delete all tests that match the url (which SHOULD be just one)
func (t Test) Delete(request *gondulapi.Request) (gondulapi.WriteReport, error) {
	if err := t.mkid(element); err != nil {
		return gondulapi.WriteReport{Failed: 1}, err
	}
	return db.Delete("results", t.CompoundID...)
}
